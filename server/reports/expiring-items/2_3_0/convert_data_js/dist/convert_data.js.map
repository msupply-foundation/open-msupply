{
  "version": 3,
  "sources": ["../../../../utils.js", "../src/utils.js", "../src/convert_data.js"],
  "sourcesContent": ["const cleanUpNodes = (nodes) => {\n  let cleanNodes = [];\n  nodes.forEach((node) => {\n    if (Object.keys(node).length != 0) {\n      cleanNodes.push(cleanUpObject(node));\n    }\n  });\n  return cleanNodes;\n};\n\nconst cleanUpObject = (node) => {\n  let newNode = {};\n  // remove empty keys which will fail to parse\n  Object.keys(node).forEach(function (key) {\n    if (node[key] !== \"\" && node[key] !== undefined && node[key] !== null) {\n      if (typeof node[key] === \"object\") {\n        // recursively remove empty strings or undefined from graphql query\n        newNode[key] = cleanUpObject(node[key]);\n      } else {\n        newNode[key] = node[key];\n      }\n    }\n  });\n  return newNode;\n};\n\nconst getNestedValue = (node, key) => {\n  key = key + \"\";\n  return key.split(\".\").reduce((value, part) => value && value[part], node);\n};\n\nconst sortNodes = (nodes, sort, dir) => {\n  if (!!sort) {\n    nodes.sort((a, b) => {\n      const valueA = getNestedValue(a, sort);\n      const valueB = getNestedValue(b, sort);\n\n      if (valueA === valueB) {\n        return 0;\n      }\n\n      if (dir === \"asc\") {\n        return valueA > valueB ? 1 : -1;\n      } else {\n        return valueA < valueB ? 1 : -1;\n      }\n    });\n  }\n\n  return nodes;\n};\n\nmodule.exports = {\n  cleanUpObject,\n  cleanUpNodes,\n  getNestedValue,\n  sortNodes,\n};\n", "import { cleanUpNodes, sortNodes, getNestedValue } from \"../../../../utils\";\n\nconst processStockLines = (nodes, sort, dir) => {\n  nodes.forEach((line) => {\n    if (Object.keys(line).length == 0) {\n      return;\n    }\n    const daysUntilExpiredFloat = calculateDaysUntilExpired(line?.expiryDate);\n    const expectedUsage = calculateExpectedUsage(\n      daysUntilExpiredFloat,\n      line?.item?.stats?.averageMonthlyConsumption\n    );\n    if (!!expectedUsage) {\n      line.expectedUsage = expectedUsage;\n    }\n    const stockAtRisk = calculateStockAtRisk(\n      line?.packSize,\n      line?.totalNumberOfPacks,\n      line?.item?.stats?.averageMonthlyConsumption,\n      daysUntilExpiredFloat\n    );\n    if (!!stockAtRisk) {\n      line.stockAtRisk = stockAtRisk;\n    }\n    line.daysUntilExpired = roundDaysToInteger(daysUntilExpiredFloat);\n  });\n  let cleanNodes = cleanUpNodes(nodes);\n  let sortedNodes = sortNodes(cleanNodes, sort, dir);\n  return sortedNodes;\n};\n\nconst calculateDaysUntilExpired = (expiryDateString) => {\n  let daysUntilExpired = undefined;\n  if (!!expiryDateString) {\n    let now = Date.now();\n    daysUntilExpired = (new Date(expiryDateString) - now) / 1000 / 60 / 60 / 24;\n  }\n  return daysUntilExpired;\n};\n\nconst calculateExpectedUsage = (\n  daysUntilExpired,\n  averageMonthlyConsumption\n) => {\n  let expectedUsage = undefined;\n  if (!!daysUntilExpired && !!averageMonthlyConsumption) {\n    if (daysUntilExpired >= 0) {\n      expectedUsage = Math.round(\n        daysUntilExpired * (averageMonthlyConsumption / 30)\n      );\n    }\n  }\n  return expectedUsage;\n};\n\nconst calculateStockAtRisk = (\n  packSize,\n  totalNumberOfPacks,\n  averageMonthlyConsumption,\n  daysUntilExpired\n) => {\n  let stockAtRisk = undefined;\n  if (!!packSize && !!totalNumberOfPacks && !!daysUntilExpired) {\n    const totalStock = packSize * totalNumberOfPacks;\n    if (!!averageMonthlyConsumption) {\n      if (daysUntilExpired >= 0) {\n        stockAtRisk = Math.round(\n          totalStock - averageMonthlyConsumption * (daysUntilExpired / 30)\n        );\n      } else {\n        stockAtRisk = Math.round(totalStock);\n      }\n    }\n    if (!averageMonthlyConsumption) {\n      if (daysUntilExpired <= 0) {\n        stockAtRisk = Math.round(totalStock);\n      }\n    }\n  }\n  return stockAtRisk;\n};\n\nconst roundDaysToInteger = (daysUntilExpired) => {\n  let rounded = undefined;\n  if (!!daysUntilExpired) {\n    rounded = Math.round(daysUntilExpired);\n  }\n  return rounded;\n};\n\nmodule.exports = {\n  calculateExpectedUsage,\n  processStockLines,\n  calculateDaysUntilExpired,\n  calculateStockAtRisk,\n  roundDaysToInteger,\n  sortNodes,\n  getNestedValue,\n};\n", "import { processStockLines } from \"./utils\";\n\nfunction convert_data() {\n  let res = JSON.parse(Host.inputString());\n  res.data.stockLines.nodes = processStockLines(\n    res.data.stockLines.nodes,\n    // assign default sort values\n    res?.arguments?.sort ?? \"SOH\",\n    res?.arguments?.dir ?? \"desc\"\n  );\n  Host.outputString(JSON.stringify(res));\n}\n\nmodule.exports = {\n  convert_data,\n};\n"],
  "mappings": "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",
  "names": ["exports", "module", "require_utils", "exports", "module", "import_utils", "processStockLines"]
}
