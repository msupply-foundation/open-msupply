{
  "version": 3,
  "sources": ["../../../../utils.js", "../src/utils.js", "../src/convert_data.js"],
  "sourcesContent": ["const cleanUpNodes = (nodes) => {\n  let cleanNodes = [];\n  nodes.forEach((node) => {\n    if (Object.keys(node).length != 0) {\n      cleanNodes.push(cleanUpObject(node));\n    }\n  });\n  return cleanNodes;\n};\n\nconst cleanUpObject = (node) => {\n  let newNode = {};\n  // remove empty keys which will fail to parse\n  Object.keys(node).forEach(function (key) {\n    if (node[key] !== \"\" && node[key] !== undefined && node[key] !== null) {\n      if (typeof node[key] === \"object\") {\n        // recursively remove empty strings or undefined from graphql query\n        newNode[key] = cleanUpObject(node[key]);\n      } else {\n        newNode[key] = node[key];\n      }\n    }\n  });\n  return newNode;\n};\n\nmodule.exports = {\n  cleanUpObject,\n  cleanUpNodes,\n};\n", "import { cleanUpNodes } from \"../../../../utils\";\n\nconst processStockLines = (nodes, sortBy) => {\n  nodes.forEach((line) => {\n    if (Object.keys(line).length == 0) {\n      return;\n    }\n    const daysUntilExpiredFloat = calculateDaysUntilExpired(line?.expiryDate);\n    const expectedUsage = calculateExpectedUsage(\n      daysUntilExpiredFloat,\n      line?.item?.stats?.averageMonthlyConsumption\n    );\n    if (!!expectedUsage) {\n      line.expectedUsage = expectedUsage;\n    }\n    const stockAtRisk = calculateStockAtRisk(\n      line?.packSize,\n      line?.totalNumberOfPacks,\n      line?.item?.stats?.averageMonthlyConsumption,\n      daysUntilExpiredFloat\n    );\n    if (!!stockAtRisk) {\n      line.stockAtRisk = stockAtRisk;\n    }\n    line.daysUntilExpired = roundDaysToInteger(daysUntilExpiredFloat);\n  });\n  let cleanNodes = cleanUpNodes(nodes);\n  sortedNodes = sortNodes(cleanNodes, sortBy);\n  return sortedNodes;\n};\n\nconst calculateDaysUntilExpired = (expiryDateString) => {\n  let daysUntilExpired = undefined;\n  if (!!expiryDateString) {\n    let now = Date.now();\n    daysUntilExpired = (new Date(expiryDateString) - now) / 1000 / 60 / 60 / 24;\n  }\n  return daysUntilExpired;\n};\n\nconst calculateExpectedUsage = (\n  daysUntilExpired,\n  averageMonthlyConsumption\n) => {\n  let expectedUsage = undefined;\n  if (!!daysUntilExpired && !!averageMonthlyConsumption) {\n    if (daysUntilExpired >= 0) {\n      expectedUsage = Math.round(\n        daysUntilExpired * (averageMonthlyConsumption / 30)\n      );\n    }\n  }\n  return expectedUsage;\n};\n\nconst calculateStockAtRisk = (\n  packSize,\n  totalNumberOfPacks,\n  averageMonthlyConsumption,\n  daysUntilExpired\n) => {\n  let stockAtRisk = undefined;\n  if (!!packSize && !!totalNumberOfPacks && !!daysUntilExpired) {\n    const totalStock = packSize * totalNumberOfPacks;\n    if (!!averageMonthlyConsumption) {\n      if (daysUntilExpired >= 0) {\n        stockAtRisk = Math.round(\n          totalStock - averageMonthlyConsumption * (daysUntilExpired / 30)\n        );\n      } else {\n        stockAtRisk = Math.round(totalStock);\n      }\n    }\n    if (!averageMonthlyConsumption) {\n      if (daysUntilExpired <= 0) {\n        stockAtRisk = Math.round(totalStock);\n      }\n    }\n  }\n  return stockAtRisk;\n};\n\nconst roundDaysToInteger = (daysUntilExpired) => {\n  let rounded = undefined;\n  if (!!daysUntilExpired) {\n    rounded = Math.round(daysUntilExpired);\n  }\n  return rounded;\n};\n\nfunction getNestedValue(node, key) {\n  return key.split(\".\").reduce((value, part) => value && value[part], node);\n}\n\nconst sortNodes = (nodes, sortBy) => {\n  let { sort, dir } = sortBy;\n\n  sort = sort ?? \"expiryDate\";\n  dir = dir ?? \"desc\";\n\n  // Perform the sort\n  nodes.sort((a, b) => {\n    const valueA = getNestedValue(a, sort);\n    const valueB = getNestedValue(b, sort);\n\n    if (valueA === valueB) {\n      return 0; // If the values are the same, don't change the order\n    }\n\n    if (dir === \"asc\") {\n      return valueA > valueB ? 1 : -1;\n    } else {\n      return valueA < valueB ? 1 : -1;\n    }\n  });\n\n  return nodes;\n};\n\nmodule.exports = {\n  calculateExpectedUsage,\n  processStockLines,\n  calculateDaysUntilExpired,\n  calculateStockAtRisk,\n  roundDaysToInteger,\n};\n", "import { processStockLines } from \"./utils\";\n\nfunction convert_data() {\n  let res = JSON.parse(Host.inputString());\n  console.log(\n    \"#### sort by: \",\n    res.arguments.sortBy.sort,\n    res.arguments.sortBy.dir\n  );\n  res.data.stockLines.nodes = processStockLines(\n    res.data.stockLines.nodes,\n    res.arguments.sortBy\n  );\n  Host.outputString(JSON.stringify(res));\n}\n\nmodule.exports = {\n  convert_data,\n};\n"],
  "mappings": "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",
  "names": ["exports", "module", "require_utils", "exports", "module", "import_utils", "processStockLines"]
}
