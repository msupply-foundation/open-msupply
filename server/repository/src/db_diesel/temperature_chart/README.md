### Aggregated temperature chart

The purpose of this repository is to provide aggregated temperature chart data to the front end.
This work is best outsourced to the database, to avoid excessive serialisations and use the power of the DB engine.

## Details

Temperature logs are aggregated across a series of intervals, grouped by sensor id, we want to achieve a query similar to this:
```sql
SELECT avg(temperature), sensor_id, from_datetime, to_datetime FROM 
    SELECT {interval_1_start_datetime} as from_datetime, {interval_1_end_datetime} as to_datetime
    UNION SELECT {interval_2_start_datetime} as from_datetime, {interval_2_end_datetime} as to_datetime 
    UNION SELECT {interval_3_start_datetime} as from_datetime, {interval_3_end_datetime} as to_datetime 
JOIN temperature_log ON (datetime >= from_datetime and datetime < to_datetime)
GROUP BY sensor_id, from_datetime, to_datetime
WHERE {temperature_log_filter}
```

In the above statement, `interval_2_start_datetime == interval_1_end_datetime` and `interval_3_start_datetime ==interval_2_end_datetime`.

Time series method can probably be used, but due to sqlite versions compatibility, we use text field for datetime columns in sqlite, thus it's easier to just construct raw sql. 
Either way raw sql would need to be used in diesel, and in order to use existing diesel filter (TemperatureLog::create_filter_query) we need to create basic diesel types.

temperature_chart_row.rs reduces code generated by `diesel::table!` macro to bare minimum, and modifies it to provide diesel types for the raw sql statement. temperature_chart.rs uses these types to create typed sql query, with group by clause:

```rs
let query = query.
    .select((FromDatetime, ToDatetime, AverageTemperature, SensorId))
    .group_by((FromDatetime, ToDatetime, SensorId));
```

## Diesel types

To understand temperature_chart_row types it's best to look at a basic example of expanded macro, modified to generate hard coded time series:

```
table!(
    time_series(from_datetime) {
        from_datetime -> Timestamp,
        to_datetime -> Timestamp,
    }
);
```

This macro can be expanded with rust analyzer in vscode (cursor on the macro instance, command pallet -> expand macro..)

[This diff](https://github.com/msupply-foundation/open-msupply/compare/4744c298335e7fa2de999e9155627cff86723919...2a775d105ef49a0490a21d7df950ab1dd35864d8) shows the changes to make diesel typed raw sql query resulting in:

```sql
SELECT timeseries.`from_datetime` FROM 
            SELECT '2021-01-01T16:00:00' as from_datetime, '2021-01-01T17:00:00' as to_datetime
            UNION SELECT '2021-01-01T17:00:00' as from_datetime, '2021-01-01T18:00:00' as to_datetime
            UNION SELECT '2021-01-01T18:00:00' as from_datetime, '2021-01-01T19:00:00' as to_datetime GROUP BY timeseries.`to_datetime` -- binds: []
```

The main difference in the diff is that `QueryFragment` was created for `from_clause` rather than using the `Identifier` for the table. Also `QueryFragment` for the columns is adjusted to account for the  `from_clause` being changed.

Expanded macro was reduced to bare minimum and `temperature_chart_column!` macro create to help with column generation

## Notes

Ideally the aggregated charts query would return all intervals, for all filtered sensors with missing temperatures for the interval as null. 
This would require the filtering to be done on the join as oppose to main where clause and another join to sensors:

```sql
SELECT ...
JOIN temperautre_log ON (datetime >= from_datetime and datetime < to_datetime) AND WHERE {temperature_log_filter}
JOIN sensor
WHERE {sensor_filter}
```

Above requires quite a lot more diesel trait implementations, so we've gone with inner join for temperature_logs and intervals, which means if temperature logs are misssing for the interval/sensor, the interval will be missing. 
But, since intervals will be returned by the repository/service and available to the front end, it would be easy to build a chart with base empty series (with all of the intervals), making the missing sensor/interval data visible.